{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b32d108b_f1be5bf2",
        "filename": "src/ipmiblob/ipmi_handler.cpp",
        "patchSetId": 3
      },
      "lineNbr": 80,
      "author": {
        "id": 1000885
      },
      "writtenOn": "2024-07-16T00:49:47Z",
      "side": 1,
      "message": "this is not working as expected.",
      "range": {
        "startLine": 80,
        "startChar": 2,
        "endLine": 80,
        "endChar": 11
      },
      "revId": "3e4a9758b104711555f87d8885c9bb7dd5713376",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "df6eebd7_dbe352a3",
        "filename": "src/ipmiblob/ipmi_handler.cpp",
        "patchSetId": 3
      },
      "lineNbr": 80,
      "author": {
        "id": 1000885
      },
      "writtenOn": "2024-07-16T03:32:36Z",
      "side": 1,
      "message": "Tested it out with unit tests and works as expected.\n\nBasically want to make sure that it block the other thread until the current once finished... and if the current one failed... it will call again instead of skipping it.",
      "parentUuid": "b32d108b_f1be5bf2",
      "range": {
        "startLine": 80,
        "startChar": 2,
        "endLine": 80,
        "endChar": 11
      },
      "revId": "3e4a9758b104711555f87d8885c9bb7dd5713376",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}